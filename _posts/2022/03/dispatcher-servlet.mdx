---
title: 'Spring: DispatcherServlet'
permalink: spring-dispatchet-servlet
type: post
date: 2022-03-24T02:43:28.824Z
authors:
  - kacper-polak
category: Spring
thumbnail:
  url: TODO
  width: 1920
  height: 1004
---

Poprzedni wpis przybliżył Ci temat kontenerów IoC w Springu. Z tego artykułu dowiesz się czym jest Servlet, DispatcherServlet, jak działa, jak go skonfigurować oraz dlaczego pełni tak ważną rolę w budowaniu aplikacji webowych. Zapraszam do lektury!

---

## Servlet

Okej, artykuł ten dotyczy głównie DispatcherServlet'a, ale czy jest sam Servlet? Słówko to nie ma żadnego sensownego tłumaczenia na język polski, więc posłużę się [oficjalną definicją od Oracle](https://docs.oracle.com/javaee/6/tutorial/doc/bnafe.html):

> **Serwlet** to **klasa** w języku programowania Java, która służy do rozszerzana możliwości serwerów obsługujących aplikacje, do których dostęp uzyskuje się za pomocą modelu programowania żądanie-odpowiedź (*request-response*). Chociaż serwlety mogą odpowiadać na każdy rodzaj żądań, są powszechnie używane do rozszerzania aplikacji obsługiwanych przez serwery WWW. Dla takich aplikacji technologia Java Servlet definiuje klasy serwletów specyficzne dla HTTP.

Wiem, że definicja może być dla Ciebie niejasna więc pozwól, że wytłumaczę Ci to własnymi słowami.

Zacznijmy najpierw od wytłumaczenia sobie czym jest **serwer WWW**. Najprościej można powiedzieć, że odpowiada on za obsługę żądań HTTP oraz wysyłanie odpowiedzi do klienta. Wraz z uruchomieniem serwera WWW (np. [Tomcat](https://tomcat.apache.org/)) tworzony jest kontener serwletów (lub zamiennie nazywany kontener aplikacji), który ładuje oraz instancjuje wszystkie serwlety. Zadaniem serwleta jest przyjęcie żądania, obsłużenie go oraz odesłanie odpowiedzi do klienta. Gdy serwer WWW odbierze żądanie, odwoła się do kontenera serwletów, który przekaże je dalej do odpowiedniego serwleta. Co ci to daje? Na przykład nie musisz wykonywać żmudnej roboty w postaci samodzielnego tworzenia serwera WWW oraz rejestrowaniu kontrolerów tak jak to jest w przypadku niektórych innych frameworków. Twoim jedynym zadaniem jest napisanie klasy, która obsłuży żądanie, a spięciem wszystkiego w całość zajmie się kontener serwletów i serwer WWW. Ponadto Twoja aplikacja będzie działać na każdym serwerze posiadającym wsparcie dla Jakarta Servlet, nie jesteś więc zależny od konkretnej implementacji. Jeżeli z jakiegoś powodu musisz zmienić serwer to po prostu to robisz.

Mówimy ciągle o serwerach WWW, ale czy serwlery mogą istnieć poza nimi? Oczywiście, że tak! W definicji pisze, że mogą one odpowiadać na każdy rodzaj żądań, czyli nie tylko na te związane ze stroną internetową, ale to właśnie tam znalazły one największe zastosowanie we współpracy z protokołem HTTP i dlatego najczęściej je tam spotkasz.

Okej, to na tyle z tej przygnębiającej teorii, przyszedł czas na praktykę, więc stwórzmy swój własny serwlet. Aby to zrobić wystarczy, że zaimplementujesz interfejs [Servlet](https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html) w swojej klasie. Do obsługi żądania od klienta służy metoda [service](https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html#service-javax.servlet.ServletRequest-javax.servlet.ServletResponse-). Przyjmuje ona jako argumenty kolejno obiekt żądania oraz obiekt odpowiedzi. Uwierz mi jednak, że nie chcesz w taki sposób tworzyć serwletów. Nie masz chociażby gotowego rozróżniania metod HTTP, więc musisz robić to ręcznie za pomocą warunków, a wad jest więcej. Najlepszym sposobem będzie po prostu użycie klasy [HttpServlet](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html), która znacznie ułatwi Ci robotę:
```java
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class HelloWorldServlet extends HttpServlet {

   public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      response.setContentType("text/html");

      PrintWriter out = response.getWriter();
      out.println("<h1>Hello from Servlet</h1>");
   }
}
```
Jednak czy tyle wystarczy, żeby po wejściu na odpowiedni adres URL ujrzeć jakże piękny nagłówek **Hello from Servlet**? Możesz czuć się trochę zawiedziony, ale nie.

Nie wspomniałem jeszcze o bardzo ważnym pliku `web.xml` nazywanym również **deskryptorem wdrożenia**. To właśnie tu zmapujesz (połączysz) endpoint z konkretnym serwletem. Zobacz przykład:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
  <servlet>
    <servlet-name>HelloWorld</servlet-name>
    <servlet-class>your.servlet.class.HelloWorldServlet</servlet-class>
  </servlet>
    
  <servlet-mapping>
    <servlet-name>HelloWorld</servlet-name>
    <url-pattern>/hello-world</url-pattern>
  </servlet-mapping>
</web-app>
```
Omówmy teraz dokładnie co się tutaj dzieje. Pierwszą rzeczą jest stworzenie nowego serwleta przy użyciu tagu `<servlet>`, w środku podajesz jego nazwę, która musi być unikatowa oraz klasę. Następną rzeczą jest zmapowanie stworzonego serwleta przy użyciu tagu `<servlet-mapping>`, podajesz jego nazwę oraz endpoint, który ma obsługiwać. Jeżeli chcesz stworzyć kilka serwletów w swojej aplikacji, po prostu otwórz kilka tagów `<servlet>` oraz `<servlet-mapping>`.
 
Warto w tym miejscu podkreślić, że plik ten musi nazywać się `web.xml` oraz znajdować się bezpośrednio w folderze `WEB-INF` w pliku war. W przeciwnym wypadku kontener serwletów nie odnajdzie pliku, na podstawie którego dokona konfiguracji serwletów. Nie możesz więc wybrać sobie dowolnej lokalizacji ani nazwy.

Kolejną rzeczą jest to, że wcale nie musisz konfigurować serwletów przy użyciu XML. W nowszych aplikacjach spokojnie możesz użyć adnotacji, jednak wykracza to poza treść tego artykułu. My skupiamy się na konfiguracji XML, ponieważ to właśnie jej będziesz używał przy konfiguracji DispatcherServlet'a.

Jeżeli zrobiłeś wszystko zgodnie z artykułem oraz odpaliłeś swoją aplikację np. na Tomcat to po wejściu na endpoint `/hello-world` powinieneś ujrzeć tytuł **Hello from Servlet**.

Bogatsi o tą wiedzę przejdźmy do wyczekiwanego DispatcherServlet'a.

## DispatcherServlet
**DispatcherServlet** jest specjalną implementacją serwleta dla aplikacji opartych na Springu. Nazywa się go również **FrontController'em** czyli kontrolerem, który obsługuje wszystkie żądania strony internetowej. Co daje takie rozwiązanie? Gdyby tak nie było musiałbyś m.in. ręcznie tworzyć oddzielne serwlety dla każdego endpointa, a to byłoby trochę męczące, nie sądzisz? Ponadto posiada on również inne funkcjonalności ułatwiające tworzenie aplikacji webowych, o czym przekonasz się za chwilę. Powiedzmy więc sobie coś więcej o jego dzialaniu oraz konfiguracji.
W pierwszej kolejności przyjrzyjmy się DispatcherServlet'owi w aplikacjach opartych na wzorcu **M**odel-**V**iew-**C**ontroller:
![DispatcherServlet diagram](https://vitalflux.com/wp-content/uploads/2014/04/spring-mvc-concepts-2.jpg)
Wyjaśnijmy sobie teraz krok po kroku co dzieje się na powyższym diagramie:
1. Żądanie od klienta kierowane jest do DispatcherServlet'a (a dokładniej kontener serwletów kieruje żądanie od klienta do DispatcherServlet'a),
2. DispatcherServlet przekazuje żądanie do `HandlerMapping`, który mapuje Request URL z handlerem. Innymi słowy, przeszukuje wszystkie zarejestrowane kontrolery (klasy z adnotacją `Controller`) i zwraca ten, który obsługuje żądanie ze wskazanym endpointem. Znaleziony kontroler wraca ponownie do DispatcherServlet'a,
3. DispatcherServlet przekazuje żądanie do odpowiedniej metody w kontrolerze oznaczonej adnotacją `RequestMapping`,
4. Metoda w kontrolerze przetwarza żądanie oraz zwraca stworzony `Model` (obiekt, który jest odpowiedzialny za przechowywanie danych) wraz z `View Name` (`String`). Obiekty te ponownie trafiają do DispatcherServlet'a,
5. DispatcherServlet przekazuje zwrócony View Name do `ViewResolver'a`, który szuka widoku po jego nazwie oraz zwraca go ponownie do DispatcherServlet'a w postaci obiektu `View`. Sposób szukania widoku różni się w zależności od wybranej implementacji,
6. DispatcherServlet przekazuje wcześniej zwrócony Model do obiektu View z ViewResolver'a,
7. View przekazuje do DispatcherServlet'a odpowiedź w postaci wyjściowego interfejsu użytkownika,
8. DispatcherServlet wysyła odpowiedź do klienta.

Jak ta droga wygląda w przypadku REST API? Żadnej magii tu nie ma, po prostu nie określasz ViewResolver'a, a DispatcherServlet kończy swoją pracę na 4 kroku wysyłając odpowiedź do klienta.

## DispatcherServlet w praktyce

Będzie to moment, w którym wykorzystasz w praktyce całą dotychczasową wiedzę. Po utworzeniu nowego projektu webowego stwórz w folderze `WEB-INF` dobrze już Ci znany plik `web.xml` zwanym także deskryptorem wdrożenia:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
  <servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>WEB-INF/spring-servlet.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
    
  <servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
```

Pojawiło się tutaj kilka nowych tagów, ale większość z nich już znasz. Pierwszym krokiem jest oczywiście stworzenie nowego serwleta o nazwie `dispatcher` oraz klasie `org.springframework.web.servlet.DispatcherServlet`. Za pomocą tagów `<init-param>` oraz `<param-name>` dostarczasz DispatcherServlet'owi lokalizację pliku konfiguracyjnego dla `WebApplicationContext`, o którym czytałeś w poprzednim wpisie. Warto tutaj podkreślić, że nie musisz wcale podawać tej lokalizacji. Domyślnie DispatcherServlet będzie szukał w folderze `WEB-INF` pliku o nazwie `<servlet-name>-context.xml`, czyli w tym przypadku `dispatcher-context.xml`. Następnym nowym tagiem jest `<load-on-startup>`, który posiada dwa zadania: określenie kolejności ładowania serwletu oraz momentu, w którym ma zostać załadowany. Kolejność ładowania działa intuicyjnie, serwlety ładowane są według malejącej wartości. Na przykład serwlet z ustawioną wartością load-on-startup na 3 zostanie załadowany szybciej od tego z wartością 2, a ten szybciej od tego z wartością 1. W tym przypadku jednak nie za bardzo Ci się to przyda, ponieważ i tak masz tylko jeden serwlet. Drugie zadanie jest znacznie ważniejsze, jeżeli w ogóle nie ustawisz wartości load-on-startup lub ustawisz ją na wartość ujemną to serwlet załaduje się dopiero przy pierwszym żądaniu, co z kolei przełoży się na opóźnienie pierwszej odpowiedzi. Z tego też powodu powinno się ustawić tę wartość na dodatnią, żeby serwlet został załadowany w momencie uruchomienia serwera.

Po stworzeniu oraz skonfigurowaniu serwleta pojawia się również dobrze Ci znany tag `<servlet-mapping>`, mapuje on serwlet o nazwie `dispatcher` ze wszystkimi endpointami poprzez ustawienie wartości `url-pattern` na `/`. 

To na tyle roboty z deskryptorem wdrożenia, lećmy dalej do stworzenia pliku konfiguracyjnego dla WebApplicationContext. Na podstawie powyższej konfiguracji utwórz ten plik w folderze `WEB-INF` oraz nazwij go `spring-servlet.xml`:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="
				       http://www.springframework.org/schema/beans
	    	    http://www.springframework.org/schema/beans/spring-beans.xsd
	    	    http://www.springframework.org/schema/context
	    	    http://www.springframework.org/schema/context/spring-context.xsd
	    	    http://www.springframework.org/schema/mvc
         http://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <context:component-scan base-package="your.base.package" />
    <mvc:annotation-driven />

    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/" />
        <property name="suffix" value=".jsp" />
    </bean>
</beans>
```
Pierwszym krokiem jest włączenie opcji `component-scan`, o której mogłeś się dowiedzieć z poprzedniego artykułu. Kolejną włączaną opcją jest `annotation-driven`, o jej działaniu możesz przeczytać w [oficjalnej dokumentacji Springa](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-config-enable). Trzecim i ostatnim krokiem jest stworzenie ViewResolver'a, a dokładnie jego implementacji `InternalResourceViewResolver`. Określasz mu dodatkowo właściwości `prefix` oraz `suffix`, pierwsza z nich zostanie dodana przed zwróconą nazwą widoku, a druga po. Dla przykładu jeżeli kontroler zwróci nazwę widoku *hello* to InternalResourceViewResolver będzie go szukał w /WEB-INF/views/hello.jsp, zaraz zobaczysz to w praktyce. Jednak czy można pozbyć się tych plików XML i zamienić je na jakąś przyjaźniejszą formę? Oczywiście, że tak! W nowszych aplikacjach powinieneś raczej stosować konfigurację opartą na klasach konfiguracyjnych.
Zacznijmy więc refactor konfiguracji od zamiany pliku `spring-servlet.xml`:
```java
@Configuration
@ComponentScan("your.base.package")
@EnableWebMvc
public class WebMvcConfig implements WebMvcConfigurer {

    @Bean
    public ViewResolver viewResolver() {
        var resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");

        return resolver;
    }
}
```
Myślę, że trzeba wyjaśnić tutaj dwie rzeczy. Pierwszą z nich jest adnotacja `EnableWebMvc`, która jest po prostu odpowiednikiem `<mvc:annotation-driven />` z XML'a. Drugą rzeczą jest implementacja interfejsu `WebMvcConfigurer`. Interfejs ten definiuje metody zwrotne (*callback methods*), dzięki którym możesz konfigurować szereg różnych rzeczy, jednak nie jest to tematem tego artykułu. Po stworzeniu pliku konfiguracyjnego zostaną wywołane metody zwrotne, które pozwolą Ci nadpisać domyślną konfigurację. W tym przypadku jednak interfejs ten nie zmienia zupełnie nic, więc nawet gdy go usuniesz to wszystko wciąż powinno działać, ale raczej nie powinieneś tego robić chociażby po to, był już "tak na zaś".
Lećmy dalej i pozbądźmy się teraz konfiguracji XML z deskryptora wdrożenia. Możesz to zrobić bardzo prosto tworząc klasę, która implementuje interfejs `WebApplicationInitializer`:
```java
public class AppInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext servletContext) {
        var appContext = new AnnotationConfigWebApplicationContext();
        appContext.register(WebMvcConfig.class);

        var servlet = servletContext.addServlet("dispatcher", new DispatcherServlet(appContext));
        servlet.setLoadOnStartup(1);
        servlet.addMapping("/");
    }
}
```
Ten sposób pokazuje jednak jedynie w ramach ciekawostki, ponieważ istnieje klasa `AbstractAnnotationConfigDispatcherServletInitializer` implementująca powyższy interfejs, która jeszcze bardziej ułatwia konfigurację deskryptora wdrożenia:
```java
public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class<?>[] getRootConfigClasses() {
        return null;
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[] { WebMvcConfig.class };
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { "/" };
    }
}
```
Widzisz jakie to teraz proste? Wyjaśnię jeszcze czym różni się RootConfig od ServletConfig:
* **RootConfig** - zwykła konfiguracja aplikacji, przechowuje fasolki niezwiązane stricte z obsługą żądań webowych,
* **ServletConfig** - konfiguracja WebApplicationContext, przechowuje fasolki związane z obsługą żądań webowych.

To na tyle z konfiguracji DispatcherServlet'a, mam nadzieję, że się nie poddałeś i dotrwałeś do tego momentu. Stwórzmy teraz prosty kontroler, który obsłuży żądanie od klienta:
```java
@Controller
public class HelloWorldController {

  @GetMapping("/")
  public String getIndex() {
    return "index";
  }

  @GetMapping("/hello")
  public String getHello() {
    return "hello";
  }
}
```
Myślę, że mniej więcej powinieneś rozumieć co się tutaj dzieje. Dzięki adnotacji `Controller` klasa ta zostanie zarejestrowana jako kontroler w DispatcherServlet, dzięki czemu będzie ona zdolna do obsługi żądań. Adnotacja ta jest jednocześnie adnotacją `Component`, więc zostanie ona automatycznie wykryta przez component-scaning. Nie musisz dzięki temu rejestrować kontrolerów ręczne. Następną adnotacją jest `GetMapping`, mapuje ona konkretną metodę z konkretnym endpointem oraz metodą GET. Zwracany String jest nazwą widoku, który według wcześniejszej konfiguracji jest plikiem z rozszerzeniem `.jsp` w folderze  `/WEB-INF/views/`. Ostatnim krokiem jest stworzenie tych dwóch plików, zróbmy więc to.
`index.jsp`:
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
  <title>Index Page</title>
</head>
<body>
  <h1>Index Page</h1>
</body>
</html>
```
`hello.jsp`:
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
  <title>Hello Page</title>
</head>
<body>
  <h1>Hello Page</h1>
</body>
</html>
```
Jeżeli zrobiłeś wszystko zgodnie z artykułem oraz odpaliłeś aplikację np. na Tomcat to po wejściu na endpointy `/index` oraz `/hello` powinieneś ujrzeć odpowiednio nagłówek **Index Page** oraz **Hello Page**.

## Podsumowanie
Artykuł ten przybliżył Ci temat serwletów, DispatcherServlet'a, sposób jego działania oraz konfiguracji. Jeżeli wytrwałeś do tego momentu to wiedz, że możesz być z siebie dumny gdyż była to na prawdę długa lektura.